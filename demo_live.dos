// use ctpmarketdatastream to replay
ctp_data_stream = streamTable(1000:0, ctpMarketDataStream.schema().colDefs.name, ctpMarketDataStream.schema().colDefs.typeString)
enableTableShareAndPersistence(table=ctp_data_stream, tableName=`ctp_data_stream_shared)

// set target symbols
target_symbols=`m2601`y2601


// adjust the tick stream
enableTableShareAndPersistence(table=streamTable(1000:0, `latency`count`trade_time`symbol`trade_date`last_price`open_price`high_price`low_price`volume`turnover`upper_limit_price`lower_limit_price`bid_price`bid_volume`ask_price`ask_volume, [LONG,INT,TIME,SYMBOL,DATE,DOUBLE,DOUBLE,DOUBLE,DOUBLE,LONG,DOUBLE,DOUBLE,DOUBLE,DOUBLE,LONG,DOUBLE,LONG]), tableName=`adjusted_tick_stream)
go

adjust_tick_metrics = <[
    tradeTime,
    InstrumentID,
    TradingDay,
    LastPrice,
    OpenPrice,
    HighestPrice,
    LowestPrice,
    long(Volume),
    Turnover,
    UpperLimitPrice,
    LowerLimitPrice,
    BidPrice1,
    BidVolume1,
    AskPrice1,
    AskVolume1
]>

createReactiveStateEngine(name="tickAdjustEngine", metrics=adjust_tick_metrics,dummyTable=ctp_data_stream_shared, outputTable=adjusted_tick_stream,filter=<InstrumentID in target_symbols>,outputElapsedMicroseconds=true)

subscribeTable(tableName=`ctp_data_stream_shared, actionName="tickAdjust", handler=getStreamEngine("tickAdjustEngine"), msgAsTable=true)

// aggregate tick data to 1min bar
enableTableShareAndPersistence(table=streamTable(1000:0, `trade_time`symbol`latency`trade_date`open`high`low`close`volume`turnover, [TIME,SYMBOL,LONG,DATE,DOUBLE,DOUBLE,DOUBLE,DOUBLE,LONG,DOUBLE]), tableName=`bar_stream_1min)
go

tsagg_1min=createTimeSeriesEngine(name="tsAgg_1min", windowSize=60000, step=60000, metrics=<[last(trade_date), first(open_price), max(high_price), min(low_price), last(last_price), last(volume)-first(volume), last(turnover)-first(turnover)]>, dummyTable=adjusted_tick_stream, outputTable=bar_stream_1min, timeColumn="trade_time", useSystemTime=false, keyColumn="symbol",outputElapsedMicroseconds=true)

subscribeTable(tableName=`adjusted_tick_stream, actionName=`tsAgg_1min, handler=getStreamEngine("tsAgg_1min"), msgAstable=true, offset=-1)

// split bar stream into two seperate streams
enableTableShareAndPersistence(table=streamTable(1000:0, `symbol`latency`count`trade_time`trade_date`price, [SYMBOL,LONG,INT,TIME,DATE,DOUBLE]), tableName=`y_bar_stream)
go

enableTableShareAndPersistence(table=streamTable(1000:0, `symbol`latency`count`trade_time`trade_date`price, [SYMBOL,LONG,INT,TIME,DATE,DOUBLE]), tableName=`m_bar_stream)
go

createReactiveStateEngine(name="filterengine1", metrics=<[trade_time,trade_date,close]>,dummyTable=bar_stream_1min, outputTable=y_bar_stream,keyColumn="symbol",filter=<symbol == `y2601>,outputElapsedMicroseconds=true)

subscribeTable(tableName=`bar_stream_1min, actionName="filterengine1", handler=getStreamEngine("filterengine1"), msgAsTable=true)

createReactiveStateEngine(name="filterengine2", metrics=<[trade_time,trade_date,close]>,dummyTable=bar_stream_1min, outputTable=m_bar_stream,keyColumn="symbol",filter=<symbol == `m2601>,outputElapsedMicroseconds=true)

subscribeTable(tableName=`bar_stream_1min, actionName="filterengine2", handler=getStreamEngine("filterengine2"), msgAsTable=true)

// left semi join two stream into one stream
enableTableShareAndPersistence(table=streamTable(1000:0, `trade_time`trade_date`price_ratio, [TIME,DATE,DOUBLE]), tableName=`ratio_stream)
go

lsjEngine=createLeftSemiJoinEngine(name="join_ratio", leftTable=y_bar_stream, rightTable=m_bar_stream, outputTable=ratio_stream,  metrics=<[y_bar_stream.trade_date, y_bar_stream.price/m_bar_stream.price]>, matchingColumn=`trade_time, updateRightTable=true)

subscribeTable(tableName=`y_bar_stream, actionName="join_ratio_left", offset=-1, handler=appendForJoin{lsjEngine, true}, msgAsTable=true)

subscribeTable(tableName=`m_bar_stream, actionName="join_ratio_right", offset=-1, handler=appendForJoin{lsjEngine, false}, msgAsTable=true)

// bband calculation
enableTableShareAndPersistence(table=streamTable(1000:0, `latency`count`trade_time`trade_date`price_ratio`upper`mean`lower, [LONG,INT,TIME,DATE,DOUBLE,DOUBLE,DOUBLE,DOUBLE]), tableName=`bband_value_stream)
go

use ta
ta_bband_Metrics = <[
    trade_time,
    trade_date,
    price_ratio,
    ta::bBands(price_ratio, timePeriod=2, nbdevUp=1, nbdevDn=1, maType=0)[0] as `upper,
    ta::bBands(price_ratio, timePeriod=2, nbdevUp=1, nbdevDn=1, maType=0)[1] as `mean,
    ta::bBands(price_ratio, timePeriod=2, nbdevUp=1, nbdevDn=1, maType=0)[2] as `lower
]>
createReactiveStateEngine(name="ta_bband_engine",
metrics=ta_bband_Metrics, dummyTable=ratio_stream, outputTable=bband_value_stream, keepOrder=true,outputElapsedMicroseconds=true)

subscribeTable(tableName=`ratio_stream, actionName="ta_bband_engine", handler=getStreamEngine("ta_bband_engine"), msgAsTable=true)

// create signal stream
enableTableShareAndPersistence(table=streamTable(1000:0, `latency`count`trade_time`trade_date`signal, [LONG,INT,TIME,DATE,INT]), tableName=`bband_signal_stream)
go

def signal_(price_ratio_, high_, low_, price_ratio_prev_, high_prev_, low_prev_){
    temp_ratio = price_ratio_[0]
    temp_ratio_prev = price_ratio_prev_[0]
    temp_high = high_[0]
    temp_high_prev = high_prev_[0]
    temp_low = low_[0]
    temp_low_prev = low_prev_[0]
    if (temp_ratio is null or temp_ratio_prev is null){
        temp_signal = 0
    }
    else if (temp_ratio>temp_high and temp_ratio_prev<=temp_high_prev){
        temp_signal = 1
    }
    else if (temp_ratio<temp_low and temp_ratio_prev>=temp_low_prev){
        temp_signal = -1
    }
    else {
        temp_signal = 0
    }
    return temp_signal
}

createReactiveStateEngine(name="bband_signal_engine",
metrics=<[trade_time, trade_date, signal_(price_ratio,upper,lower,prev(price_ratio),prev(upper),prev(lower))]>, dummyTable=bband_value_stream, outputTable=bband_signal_stream, keepOrder=true,outputElapsedMicroseconds=true)

subscribeTable(tableName=`bband_value_stream, actionName="bband_signal_engine", handler=getStreamEngine("bband_signal_engine"), msgAsTable=true)

// create order stream
enableTableShareAndPersistence(table=streamTable(1000:0, `latency`count`trade_time`trade_date`long_symbol`short_symbol, [LONG,INT,TIME,DATE,STRING,STRING]), tableName=`bband_order_stream)
go

def order_(order_){
    temp_order = order_[0]
    if (temp_order == 1){
        return `y2601`m2601
    }
    else{
        return `m2601`y2601
    }
}

createReactiveStateEngine(name="bband_order_engine",
metrics=[<trade_time>, <trade_date>, <order_(signal)[0]>,<order_(signal)[1]>], dummyTable=bband_signal_stream, outputTable=bband_order_stream, filter=<signal is not null and signal != 0>, keepOrder=true,outputElapsedMicroseconds=true)

subscribeTable(tableName=`bband_signal_stream, actionName="bband_order_engine", handler=getStreamEngine("bband_order_engine"), msgAsTable=true)

// replay 

table1 = select * from ctpMarketDataStream limit 10000
replay(inputTables=table1, outputTables=ctp_data_stream, timeColumn=`tradeTime)


unsubscribeTable(tableName=`ctp_data_stream_shared, actionName="tickAdjust")
unsubscribeTable(tableName=`bar_stream_1min, actionName="filterengine2")
unsubscribeTable(tableName=`adjusted_tick_stream, actionName=`tsAgg_1min)
unsubscribeTable(tableName=`bar_stream_1min, actionName="filterengine1")
unsubscribeTable(tableName=`y_bar_stream, actionName="join_ratio_left")
unsubscribeTable(tableName=`m_bar_stream, actionName="join_ratio_right")
unsubscribeTable(tableName=`ratio_stream, actionName="ta_bband_engine")
unsubscribeTable(tableName=`bband_value_stream, actionName="bband_signal_engine")
unsubscribeTable(tableName=`bband_signal_stream, actionName="bband_order_engine")

dropStreamEngine(`tickAdjustEngine)
dropStreamEngine(`tsAgg_1min)
dropStreamEngine(`filterengine1)
dropStreamEngine(`filterengine2)
dropStreamEngine(`join_ratio)
dropStreamEngine(`ta_bband_engine)
dropStreamEngine(`bband_order_engine)
dropStreamEngine(`bband_signal_engine)

dropStreamTable(`adjusted_tick_stream)
dropStreamTable(`bar_stream_1min)
dropStreamTable(`ctp_data_stream_shared)
dropStreamTable(`y_bar_stream)
dropStreamTable(`m_bar_stream)
dropStreamTable(`ratio_stream)
dropStreamTable(`bband_value_stream)
dropStreamTable(`bband_signal_stream)
dropStreamTable(`bband_order_stream)
